import static java.lang.Runtime.getRuntime;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.nio.file.FileAlreadyExistsException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.Year;
import java.time.ZoneId;
import java.util.Comparator;
import java.util.Formatter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.zip.DeflaterOutputStream;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;

public class Main {

    static Map<String, String> props = new HashMap<>();
    static String USAGE = "java -jar wzorzec.jar file [year]";
    static String COMMIT_BODY = "Generated by [wzorzec](https://github.com/codeleventh/wzorzec)";

    enum ObjectType {blob, tree, commit;}

    static Logger logger = Logger.getLogger(Main.class);

    static byte[] addHeader(String s, ObjectType type) throws UnsupportedEncodingException, IOException {
        return addHeader(s.getBytes(), type);
    }

    static byte[] addHeader(byte[] bytes, ObjectType type) throws IOException {
        String h = type.toString() + " " + bytes.length;
        byte[] header = h.getBytes();

        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        stream.write(header);
        stream.write((byte) 0x00);
        stream.write(bytes);

        return stream.toByteArray();
    }

    static String getSHA1(byte[] input) {
        try {
            MessageDigest crypt = MessageDigest.getInstance("SHA-1");
            crypt.reset();
            crypt.update(input);

            Formatter formatter = new Formatter();
            for (byte b : crypt.digest()) {
                formatter.format("%02x", b);
            }
            String sha1 = formatter.toString();
            formatter.close();
            return sha1;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            throw new RuntimeException();
        }
    }

    static void deflateFile(Path filepath) throws IOException {
        byte[] input = Files.readAllBytes(filepath);

        ByteArrayOutputStream output = new ByteArrayOutputStream();
        DeflaterOutputStream stream = new DeflaterOutputStream(output);
        stream.write(input);
        stream.flush();
        stream.close();

        Files.write(filepath, output.toByteArray());
    }

    static Path createFile(Path filePath) throws IOException {
        try {
            Files.createDirectories(filePath.getParent());
            Files.createFile(filePath);
        } catch (FileAlreadyExistsException e) {
        }
        return filePath;
    }

    static String writeObject(String body, ObjectType type) throws IOException {
        return writeObject(body.getBytes(), type);
    }

    static String writeObject(byte[] body, ObjectType type) throws IOException {
        byte[] bytes = addHeader(body, type);
        String hash = getSHA1(bytes);

        Path path = Paths.get(props.get("repository.name") + "/.git/objects/"
                                  + hash.substring(0, 2) + "/" + hash.substring(2));
        createFile(path);

        Files.write(path, bytes);
        deflateFile(path);

        // logger.log(Level.INFO, "writing " + type + ":\t" + hash);
        return hash;
    }

    static String doBlob(String body) throws IOException {
        return writeObject(COMMIT_BODY, ObjectType.blob);
    }

    static String doTree(String blobHash) throws IOException {
        byte[] blobHashRaw = new byte[20];

        try {
            if (blobHash.length() != 40) {
                throw new Exception();
            }
            for (int i = 0; i < 40; i += 2) {
                blobHashRaw[i / 2] = (byte) Integer.parseInt(blobHash.substring(i, i + 2), 16);
            }
        } catch (Exception e) {
            throw new RuntimeException("Incorrect blob hash: " + blobHash);
        }

        ByteArrayOutputStream stream = new ByteArrayOutputStream();
        stream.write("100644 README.md\0".getBytes());
        stream.write(blobHashRaw);
        return writeObject(stream.toByteArray(), ObjectType.tree);
    }

    static String doCommit(LocalDate date, String treeHash, String parentHash) throws IOException {
        long unixtime = LocalDateTime.of(date, LocalTime.NOON).atZone(ZoneId.systemDefault()).toEpochSecond();

        String body = "tree " + treeHash + "\n";
        if (parentHash != null) {
            body += "parent " + parentHash + "\n";
        }
        body += String.format("author %s <%s> %d +0000\n",
                              props.get("commit.author"), props.get("commit.email"), unixtime)
            + String.format("committer %s <%s> %d +0000\n",
                            props.get("commit.author"), props.get("commit.email"), unixtime)
            + "\n\n";
        return writeObject(body, ObjectType.commit);
    }

    static int markToInt(char c) {
        switch (c) {
            case '█':
            case '4':
                return 4;
            case '▓':
            case '3':
                return 3;
            case '▒':
            case '2':
                return 2;
            case '░':
            case '1':
                return 1;
            default:
                return 0;
        }
    }

    public static void main(String... args) throws IOException {
        try {
            Properties properties = new Properties();
            InputStream stream = new FileInputStream("wzorzec.properties");
            properties.load(stream);

            if (properties.isEmpty()) {
                logger.log(Level.ERROR, "Properties file not found");
                System.exit(-1);
            }

            props = (Map) properties;
            if (properties.getProperty("commit.author") == null ||
                properties.getProperty("commit.email") == null ||
                properties.getProperty("repository.name") == null ||
                properties.getProperty("github.profile") == null) {
                logger.log(Level.ERROR, "Some properties not found");
                System.exit(-1);
            }

        } catch (Exception e) {
            logger.log(Level.ERROR, "Bad properties file: " + e.getMessage());
            System.exit(-1);
        }

        Integer year = Year.now().getValue();

        Boolean wrongArgs = false;
        if (args.length == 0 || args.length > 2) {
            logger.log(Level.INFO, "Usage: " + USAGE);
            System.exit(0);
        }
        if (!Files.isReadable(Paths.get(args[0]))) {
            logger.log(Level.ERROR, "Cannot open " + args[0]);
            System.exit(-1);
        }
        if (args.length > 1) {
            try {
                year = Integer.parseInt(args[1]);
            } catch (NumberFormatException e) {
                logger.log(Level.ERROR, "Invalid year: " + args[1]);
                System.exit(-1);
            }
        }

        List<String> inStrings = Files.readAllLines(Paths.get(args[0]));
        if (inStrings.size() != 7) {
            System.out.println("wrong input file structure");
            System.exit(-1);
        }
        for (String s : inStrings) {
            s = s.replace("\r", "");
            s = s.replace("\n", "");
            if (s.length() != 53) {
                logger.log(Level.ERROR, "Wrong input file structure. Check the blank.txt file");
                System.exit(-1);
            }
            System.out.println(s);
        }

        if (Files.exists(Paths.get(props.get("repository.name")))) {
            Files.walk(Paths.get(props.get("repository.name")))
                .sorted(Comparator.reverseOrder())
                .map(Path::toFile)
                .forEach(File::delete);
        }

        try {
            Process p = getRuntime().exec("git init " + props.get("repository.name")); // catch no git
            BufferedReader input = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String stdout = input.readLine();
            input.close();

            if (stdout == null ||
                !(stdout.startsWith("Initialized empty")
                    || stdout.startsWith("Reinitialized existing"))) {
                logger.log(Level.ERROR, "Is Git in %path% variable? Can't (re)initialize repository");
                System.exit(-1);
            }
        } catch (IOException e) {
            logger.log(Level.ERROR, "Is git in %path% variable? Can't (re)initialize repository: " + e.getMessage());
            System.exit(-1);
        }

        LocalDate date, dateFrom = LocalDate.of(year, 1, 1);
        while (dateFrom.getDayOfWeek() != DayOfWeek.SUNDAY) {
            dateFrom = dateFrom.minusDays(1);
        }

        date = dateFrom;
        Stats commits = new Stats();
        for (int i = 0; i < 7; i++) {
            date = dateFrom.plusDays(i);
            for (int j = 0; j < 53; j++) {
                Integer totalCommits = markToInt(inStrings.get(i).charAt(j));
                if (totalCommits != 0) {
                    commits.put(date, totalCommits);
                }
                date = date.plusWeeks(1);
            }
        }

        Stats profileCommits = null;
        try {
            profileCommits = new Stats(props.get("github.profile"), year);
            if (profileCommits.size() == 0) {
                profileCommits = null;
            }
        } catch (IOException e) {
            logger.log(Level.WARN, String.format("Cannot get %s\'s profile stats: %s",
                                                 props.get("github.profile"), e.getMessage()));
        }

        if (profileCommits != null &&
            profileCommits.getMax() > commits.getMax()) {
            commits.multiplyStats(profileCommits.getMax() / 4d);
            commits.substractStats(profileCommits);
        }

        Integer totalCommits = 0;
        String parentHash = null;
        for (Map.Entry<LocalDate, Integer> entry : commits.entrySet()) {
            for (int i = 0; i < entry.getValue(); i++) {
                parentHash = doCommit(entry.getKey(), doTree(doBlob(COMMIT_BODY)), parentHash);
                totalCommits++;
            }
        }

        Path path = createFile(Paths.get(props.get("repository.name") + "/.git/refs/heads/master"));
        Files.write(path, parentHash.getBytes());
        logger.log(Level.INFO,  totalCommits + " commits have been written");
        logger.log(Level.INFO, "master HEAD ref is updated");
    }
}